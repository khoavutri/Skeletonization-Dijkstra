{"version":3,"file":"khoadev.min.js","mappings":"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","sources":["webpack/universalModuleDefinition","/home/khoa/Desktop/easy-study/webpack-base/src/models/skeletonization.ts","/home/khoa/Desktop/easy-study/webpack-base/src/index.ts","/home/khoa/Desktop/easy-study/webpack-base/src/utils/convertLocation.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"khoadev\"] = factory();\n\telse\n\t\troot[\"khoadev\"] = factory();\n})(self, () => {\nreturn ","var Point = /** @class */ (function () {\n    function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    return Point;\n}());\nvar Skeletonization = /** @class */ (function () {\n    function Skeletonization(grayscalePixelData, width, height) {\n        var _this = this;\n        this.toWhite = [];\n        this.nbrs = [\n            [0, -1],\n            [1, -1],\n            [1, 0],\n            [1, 1],\n            [0, 1],\n            [-1, 1],\n            [-1, 0],\n            [-1, -1],\n            [0, -1],\n        ];\n        this.nbrGroups = [\n            [\n                [0, 2, 4],\n                [2, 4, 6],\n            ],\n            [\n                [0, 2, 6],\n                [0, 4, 6],\n            ],\n        ];\n        this.data = function () {\n            var dataList = new Uint8ClampedArray(_this.grayscalePixelData.length * 4);\n            for (var i = 0; i < _this.grayscalePixelData.length; i++) {\n                dataList[i * 4] = _this.grayscalePixelData[i]; // Red\n                dataList[i * 4 + 1] = _this.grayscalePixelData[i]; // Green\n                dataList[i * 4 + 2] = _this.grayscalePixelData[i]; // Blue\n                dataList[i * 4 + 3] = 255; // Alpha\n            }\n            // === 255 ? 0 : 255\n            return new ImageData(dataList, _this.width, _this.height);\n        };\n        this.grayscalePixelData = [];\n        for (var i = 0; i < grayscalePixelData.length; i += 4) {\n            this.grayscalePixelData.push(grayscalePixelData[i]);\n        }\n        this.width = width;\n        this.height = height;\n    }\n    Skeletonization.prototype.thinImage = function () {\n        var firstStep = false;\n        var hasChanged;\n        var dem = 0;\n        do {\n            hasChanged = false;\n            firstStep = !firstStep;\n            for (var y = 1; y < this.height; y++) {\n                for (var x = 1; x < this.width; x++) {\n                    dem++;\n                    if (this.grayscalePixelData[x + y * this.width] !== 255)\n                        continue;\n                    var numberNegighbor = this.numNeighbors(x, y);\n                    if (numberNegighbor < 2 || numberNegighbor > 6) {\n                        continue;\n                    }\n                    if (this.numTransitions(x, y) !== 1)\n                        continue;\n                    if (!this.atLeastOneIsWhite(x, y, firstStep ? 0 : 1))\n                        continue;\n                    this.toWhite.push(new Point(x, y));\n                    hasChanged = true;\n                }\n            }\n            for (var _i = 0, _a = this.toWhite; _i < _a.length; _i++) {\n                var p = _a[_i];\n                this.grayscalePixelData[p.x + p.y * this.width] = 0;\n            }\n            this.toWhite = [];\n        } while (firstStep || hasChanged);\n    };\n    Skeletonization.prototype.numNeighbors = function (x, y) {\n        var count = 0;\n        for (var i = 0; i < this.nbrs.length - 1; i++) {\n            var newX = x + this.nbrs[i][0];\n            var newY = y + this.nbrs[i][1];\n            if (this.grayscalePixelData[newX + newY * this.width] === 255) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Skeletonization.prototype.numTransitions = function (x, y) {\n        var count = 0;\n        for (var i = 0; i < this.nbrs.length - 1; i++) {\n            var newX = x + this.nbrs[i][0];\n            var newY = y + this.nbrs[i][1];\n            var newNbX = x + this.nbrs[i + 1][0];\n            var newNbY = y + this.nbrs[i + 1][1];\n            if (this.grayscalePixelData[newX + newY * this.width] === 0) {\n                if (this.grayscalePixelData[newNbX + newNbY * this.width] === 255) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    };\n    Skeletonization.prototype.atLeastOneIsWhite = function (x, y, step) {\n        var group = this.nbrGroups[step];\n        var count = 0;\n        for (var i = 0; i < 2; i++) {\n            for (var _i = 0, _a = group[i]; _i < _a.length; _i++) {\n                var j = _a[_i];\n                var nbr = this.nbrs[j];\n                if (this.grayscalePixelData[x + nbr[0] + (y + nbr[1]) * this.width] === 0) {\n                    count++;\n                    break;\n                }\n            }\n        }\n        return count > 1;\n    };\n    return Skeletonization;\n}());\nexport { Skeletonization };\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { Skeletonization } from \"./models/skeletonization\";\nimport { convertLocation } from \"./utils/convertLocation\";\nvar canvas = document.getElementById(\"canvas\");\nvar points = [];\ncanvas.addEventListener(\"click\", function (e) {\n    var point = convertLocation(canvas, e.clientX, e.clientY);\n    if (points.length < 2) {\n        points.push(point);\n    }\n    else {\n        points = [point];\n    }\n    drawImage();\n});\nvar img = new Image();\nimg.crossOrigin = \"*\";\nimg.src = \"./public/xuong.jpg\";\nfunction drawImage() {\n    var context = canvas.getContext(\"2d\", { willReadFrequently: true });\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.drawImage(img, 0, 0);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    var width = canvas.width;\n    var height = canvas.height;\n    context.drawImage(img, 0, 0);\n    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    var saveImage = new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);\n    var xam = convertToGrayscale(imageData);\n    var phanlap = erosionXn(closing(opening(applyFixedThreshold(xam, 100), [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ]), [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ]), [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ], 2);\n    var duong = new Skeletonization(phanlap.data, width, height);\n    duong.thinImage();\n    var xuong = duong.data();\n    context.putImageData(saveImage, 0, 0);\n    var clickContainer = points;\n    if (clickContainer.length === 2) {\n        var start = clickContainer[0], stop_1 = clickContainer[1];\n        var minStart = findMinDistance(xuong, start);\n        var minStop = findMinDistance(xuong, stop_1);\n        var path = findShortestPath(xuong, minStart, minStop);\n        // drawLine(canvas, [minStart, minStop]);\n        if (path.length) {\n            drawLine(canvas, __spreadArray(__spreadArray([start], path, true), [stop_1], false));\n        }\n    }\n}\nimg.onload = drawImage;\nfunction createGaussianKernel(size) {\n    var sigma = size / 3;\n    var kernel = [];\n    var mean = Math.floor(size / 2);\n    var sum = 0;\n    for (var y = 0; y < size; y++) {\n        kernel[y] = [];\n        for (var x = 0; x < size; x++) {\n            var dx = x - mean;\n            var dy = y - mean;\n            var exponent = -(dx * dx + dy * dy) / (2 * sigma * sigma);\n            var value = (1 / (2 * Math.PI * sigma * sigma)) * Math.exp(exponent);\n            kernel[y][x] = value;\n            sum += value;\n        }\n    }\n    for (var y = 0; y < size; y++) {\n        for (var x = 0; x < size; x++) {\n            kernel[y][x] /= sum;\n        }\n    }\n    return kernel;\n}\nfunction applyGaussianBlur(imageData, kernel) {\n    var width = imageData.width;\n    var height = imageData.height;\n    var output = new Uint8ClampedArray(imageData.data.length);\n    var kernelSize = kernel.length;\n    var halfKernelSize = Math.floor(kernelSize / 2);\n    for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n            var r = 0, g = 0, b = 0;\n            for (var ky = -halfKernelSize; ky <= halfKernelSize; ky++) {\n                for (var kx = -halfKernelSize; kx <= halfKernelSize; kx++) {\n                    var srcX = Math.min(Math.max(x + kx, 0), width - 1);\n                    var srcY = Math.min(Math.max(y + ky, 0), height - 1);\n                    var k = kernel[ky + halfKernelSize][kx + halfKernelSize];\n                    var idx = (srcY * width + srcX) * 4;\n                    r += imageData.data[idx] * k;\n                    g += imageData.data[idx + 1] * k;\n                    b += imageData.data[idx + 2] * k;\n                }\n            }\n            var dstIdx = (y * width + x) * 4;\n            output[dstIdx] = r;\n            output[dstIdx + 1] = g;\n            output[dstIdx + 2] = b;\n            output[dstIdx + 3] = 255;\n        }\n    }\n    return new ImageData(output, width, height);\n}\nfunction convertToGrayscale(imageData) {\n    var data = imageData.data;\n    for (var i = 0; i < data.length; i += 4) {\n        var red = data[i];\n        var green = data[i + 1];\n        var blue = data[i + 2];\n        var gray = 0.299 * red + 0.587 * green + 0.114 * blue;\n        data[i] = data[i + 1] = data[i + 2] = gray;\n    }\n    return imageData;\n}\nfunction erosion(imageData, kernel) {\n    var width = imageData.width;\n    var height = imageData.height;\n    var data = imageData.data;\n    var outputData = new Uint8ClampedArray(data.length);\n    var kernelHeight = kernel.length;\n    var kernelWidth = kernel[0].length;\n    var kx = Math.floor(kernelWidth / 2);\n    var ky = Math.floor(kernelHeight / 2);\n    for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n            var minR = 255, minG = 255, minB = 255;\n            var appliedKernel = false;\n            for (var j = -ky; j <= ky; j++) {\n                for (var i = -kx; i <= kx; i++) {\n                    var newX = x + i;\n                    var newY = y + j;\n                    if (kernel[j + ky][i + kx] === 1) {\n                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n                            var idx = (newY * width + newX) * 4;\n                            minR = Math.min(minR, data[idx]);\n                            minG = Math.min(minG, data[idx + 1]);\n                            minB = Math.min(minB, data[idx + 2]);\n                            appliedKernel = true;\n                        }\n                    }\n                }\n            }\n            var outputIdx = (y * width + x) * 4;\n            if (appliedKernel) {\n                outputData[outputIdx] = minR;\n                outputData[outputIdx + 1] = minG;\n                outputData[outputIdx + 2] = minB;\n            }\n            outputData[outputIdx + 3] = data[outputIdx + 3];\n        }\n    }\n    return new ImageData(outputData, width, height);\n}\nfunction erosionXn(imageData, kernel, solan) {\n    var currentImageData = imageData;\n    for (var i = 0; i < solan; i++) {\n        currentImageData = erosion(currentImageData, kernel);\n    }\n    return currentImageData;\n}\nvar closing = function (imageData, kernel) {\n    return erosion(dilation(imageData, kernel), kernel);\n};\nfunction dilation(imageData, kernel) {\n    var width = imageData.width;\n    var height = imageData.height;\n    var data = imageData.data;\n    var outputData = new Uint8ClampedArray(data.length);\n    var kernelHeight = kernel.length;\n    var kernelWidth = kernel[0].length;\n    var kx = Math.floor(kernelWidth / 2);\n    var ky = Math.floor(kernelHeight / 2);\n    for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n            var maxR = 0, maxG = 0, maxB = 0;\n            var appliedKernel = false;\n            for (var j = -ky; j <= ky; j++) {\n                for (var i = -kx; i <= kx; i++) {\n                    var newX = x + i;\n                    var newY = y + j;\n                    if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n                        if (kernel[j + ky][i + kx] === 1) {\n                            var idx = (newY * width + newX) * 4;\n                            maxR = Math.max(maxR, data[idx]);\n                            maxG = Math.max(maxG, data[idx + 1]);\n                            maxB = Math.max(maxB, data[idx + 2]);\n                            appliedKernel = true;\n                        }\n                    }\n                }\n            }\n            var outputIdx = (y * width + x) * 4;\n            if (appliedKernel) {\n                outputData[outputIdx] = maxR;\n                outputData[outputIdx + 1] = maxG;\n                outputData[outputIdx + 2] = maxB;\n            }\n            outputData[outputIdx + 3] = data[outputIdx + 3];\n        }\n    }\n    return new ImageData(outputData, width, height);\n}\nvar findMinDistance = function (imageData, point) {\n    var data = imageData.data;\n    var width = imageData.width;\n    var height = imageData.height;\n    var min = null;\n    var minDistance = Infinity;\n    for (var i = 0; i < height; i++) {\n        for (var j = 0; j < width; j++) {\n            var index = (i * width + j) * 4;\n            if (data[index] === 255) {\n                var distance = Math.sqrt(Math.pow((point.x - j), 2) + Math.pow((point.y - i), 2));\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    min = { x: j, y: i };\n                }\n            }\n        }\n    }\n    return min;\n};\nfunction isValid(x, y, width, height) {\n    return x >= 0 && x < width && y >= 0 && y < height;\n}\nfunction findShortestPath(imageDatas, start, end) {\n    var width = imageDatas.width;\n    var height = imageDatas.height;\n    var imageData = [];\n    for (var i = 0; i < imageDatas.data.length; i += 4) {\n        imageData.push(imageDatas.data[i]);\n    }\n    var distances = new Float32Array(width * height);\n    var previous = new Array(width * height).fill(null);\n    distances.fill(Infinity);\n    var nodes = new Set();\n    function generateDirections(n) {\n        var directions = [];\n        for (var dx = -n; dx <= n; dx++) {\n            for (var dy = -n; dy <= n; dy++) {\n                if (dx !== 0 || dy !== 0) {\n                    // Loại bỏ điểm trung tâm (0, 0)\n                    directions.push({ x: dx, y: dy });\n                }\n            }\n        }\n        return directions;\n    }\n    var directions = generateDirections(1);\n    function reconstructPath(previous, end, width) {\n        var path = [];\n        var current = end;\n        while (previous[current.x + current.y * width] !== null) {\n            path.push(current);\n            var p = previous[current.x + current.y * width];\n            current = { x: p.x, y: p.y };\n        }\n        path.push(current);\n        return path.reverse();\n    }\n    distances[start.x + start.y * width] = 0;\n    nodes.add({ x: start.x, y: start.y });\n    while (nodes.size > 0) {\n        var closestNode = Array.from(nodes).reduce(function (minNode, node) {\n            var x = node.x, y = node.y;\n            return distances[x + y * width] <\n                distances[minNode.x + minNode.y * width]\n                ? node\n                : minNode;\n        });\n        nodes.delete(closestNode);\n        var _a = [closestNode.x, closestNode.y], currentX = _a[0], currentY = _a[1];\n        if (currentX === end.x && currentY === end.y) {\n            return reconstructPath(previous, end, width);\n        }\n        for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n            var direction = directions_1[_i];\n            var neighborX = currentX + direction.x;\n            var neighborY = currentY + direction.y;\n            if (isValid(neighborX, neighborY, width, height)) {\n                var pixelValue = imageData[neighborX + neighborY * width];\n                // const newDistance = distances[currentX + currentY * width] + 1;\n                var newDistance = distances[currentX + currentY * width] + (255 - pixelValue);\n                if (newDistance < distances[neighborX + neighborY * width]) {\n                    distances[neighborX + neighborY * width] = newDistance;\n                    previous[neighborX + neighborY * width] = {\n                        x: currentX,\n                        y: currentY,\n                    };\n                    nodes.add({ x: neighborX, y: neighborY });\n                }\n            }\n        }\n    }\n    return [];\n}\nfunction drawLine(canvas, points) {\n    var ctx = canvas.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (var i = 1; i < points.length; i++) {\n        ctx.lineTo(points[i].x, points[i].y);\n    }\n    ctx.strokeStyle = \"blue\";\n    ctx.lineWidth = 1.5;\n    ctx.stroke();\n}\nvar opening = function (imageData, kernel) {\n    return dilation(erosion(imageData, kernel), kernel);\n};\nfunction applyFixedThreshold(imageData, threshold) {\n    var data = imageData.data;\n    for (var i = 0; i < data.length; i += 4) {\n        var gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n        if (gray > threshold) {\n            data[i] = data[i + 1] = data[i + 2] = 0;\n        }\n        else {\n            data[i] = data[i + 1] = data[i + 2] = 255;\n        }\n    }\n    return imageData;\n}\n","export var convertLocation = function (element, clientX, clientY) {\n    var rect = element.getBoundingClientRect();\n    return { x: clientX - rect.left, y: clientY - rect.top };\n};\n"],"names":["root","factory","exports","module","define","amd","self","Point","x","y","this","Skeletonization","grayscalePixelData","width","height","_this","toWhite","nbrs","nbrGroups","data","dataList","Uint8ClampedArray","length","i","ImageData","push","prototype","thinImage","hasChanged","firstStep","numberNegighbor","numNeighbors","numTransitions","atLeastOneIsWhite","_i","_a","p","count","newX","newY","newNbX","newNbY","step","group","j","nbr","__spreadArray","to","from","pack","arguments","ar","l","Array","slice","call","concat","canvas","document","getElementById","points","addEventListener","e","element","clientX","clientY","rect","point","getBoundingClientRect","left","top","drawImage","img","Image","context","getContext","willReadFrequently","clearRect","imageData","getImageData","saveImage","xam","gray","convertToGrayscale","phanlap","kernel","solan","currentImageData","erosion","erosionXn","closing","opening","threshold","applyFixedThreshold","duong","xuong","putImageData","clickContainer","start","stop_1","path","imageDatas","end","distances","Float32Array","previous","fill","Infinity","nodes","Set","generateDirections","n","directions","dx","dy","reconstructPath","current","reverse","add","size","closestNode","reduce","minNode","node","delete","currentX","currentY","directions_1","direction","neighborX","neighborY","isValid","pixelValue","newDistance","findShortestPath","findMinDistance","ctx","beginPath","moveTo","lineTo","strokeStyle","lineWidth","stroke","drawLine","outputData","kernelHeight","kernelWidth","kx","Math","floor","ky","minR","minG","minB","appliedKernel","idx","min","outputIdx","crossOrigin","src","onload","dilation","maxR","maxG","maxB","max","minDistance","distance","sqrt","pow"],"sourceRoot":""}